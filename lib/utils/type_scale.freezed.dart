// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'type_scale.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TypeScaleTypeTearOff {
  const _$TypeScaleTypeTearOff();

  TypeScaleTypeH1 h1() {
    return const TypeScaleTypeH1();
  }

  TypeScaleTypeH2 h2() {
    return const TypeScaleTypeH2();
  }

  TypeScaleTypeH3 h3() {
    return const TypeScaleTypeH3();
  }

  TypeScaleTypeBody body() {
    return const TypeScaleTypeBody();
  }

  TypeScaleTypeBodyMono bodyMono() {
    return const TypeScaleTypeBodyMono();
  }
}

/// @nodoc
const $TypeScaleType = _$TypeScaleTypeTearOff();

/// @nodoc
mixin _$TypeScaleType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeScaleTypeCopyWith<$Res> {
  factory $TypeScaleTypeCopyWith(
          TypeScaleType value, $Res Function(TypeScaleType) then) =
      _$TypeScaleTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeCopyWith<$Res> {
  _$TypeScaleTypeCopyWithImpl(this._value, this._then);

  final TypeScaleType _value;
  // ignore: unused_field
  final $Res Function(TypeScaleType) _then;
}

/// @nodoc
abstract class $TypeScaleTypeH1CopyWith<$Res> {
  factory $TypeScaleTypeH1CopyWith(
          TypeScaleTypeH1 value, $Res Function(TypeScaleTypeH1) then) =
      _$TypeScaleTypeH1CopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeH1CopyWithImpl<$Res>
    extends _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeH1CopyWith<$Res> {
  _$TypeScaleTypeH1CopyWithImpl(
      TypeScaleTypeH1 _value, $Res Function(TypeScaleTypeH1) _then)
      : super(_value, (v) => _then(v as TypeScaleTypeH1));

  @override
  TypeScaleTypeH1 get _value => super._value as TypeScaleTypeH1;
}

/// @nodoc

class _$TypeScaleTypeH1 extends TypeScaleTypeH1 with DiagnosticableTreeMixin {
  const _$TypeScaleTypeH1() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TypeScaleType.h1()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TypeScaleType.h1'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TypeScaleTypeH1);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) {
    return h1();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) {
    return h1?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) {
    if (h1 != null) {
      return h1();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) {
    return h1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) {
    return h1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) {
    if (h1 != null) {
      return h1(this);
    }
    return orElse();
  }
}

abstract class TypeScaleTypeH1 extends TypeScaleType {
  const factory TypeScaleTypeH1() = _$TypeScaleTypeH1;
  const TypeScaleTypeH1._() : super._();
}

/// @nodoc
abstract class $TypeScaleTypeH2CopyWith<$Res> {
  factory $TypeScaleTypeH2CopyWith(
          TypeScaleTypeH2 value, $Res Function(TypeScaleTypeH2) then) =
      _$TypeScaleTypeH2CopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeH2CopyWithImpl<$Res>
    extends _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeH2CopyWith<$Res> {
  _$TypeScaleTypeH2CopyWithImpl(
      TypeScaleTypeH2 _value, $Res Function(TypeScaleTypeH2) _then)
      : super(_value, (v) => _then(v as TypeScaleTypeH2));

  @override
  TypeScaleTypeH2 get _value => super._value as TypeScaleTypeH2;
}

/// @nodoc

class _$TypeScaleTypeH2 extends TypeScaleTypeH2 with DiagnosticableTreeMixin {
  const _$TypeScaleTypeH2() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TypeScaleType.h2()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TypeScaleType.h2'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TypeScaleTypeH2);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) {
    return h2();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) {
    return h2?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) {
    if (h2 != null) {
      return h2();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) {
    return h2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) {
    return h2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) {
    if (h2 != null) {
      return h2(this);
    }
    return orElse();
  }
}

abstract class TypeScaleTypeH2 extends TypeScaleType {
  const factory TypeScaleTypeH2() = _$TypeScaleTypeH2;
  const TypeScaleTypeH2._() : super._();
}

/// @nodoc
abstract class $TypeScaleTypeH3CopyWith<$Res> {
  factory $TypeScaleTypeH3CopyWith(
          TypeScaleTypeH3 value, $Res Function(TypeScaleTypeH3) then) =
      _$TypeScaleTypeH3CopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeH3CopyWithImpl<$Res>
    extends _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeH3CopyWith<$Res> {
  _$TypeScaleTypeH3CopyWithImpl(
      TypeScaleTypeH3 _value, $Res Function(TypeScaleTypeH3) _then)
      : super(_value, (v) => _then(v as TypeScaleTypeH3));

  @override
  TypeScaleTypeH3 get _value => super._value as TypeScaleTypeH3;
}

/// @nodoc

class _$TypeScaleTypeH3 extends TypeScaleTypeH3 with DiagnosticableTreeMixin {
  const _$TypeScaleTypeH3() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TypeScaleType.h3()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TypeScaleType.h3'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TypeScaleTypeH3);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) {
    return h3();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) {
    return h3?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) {
    if (h3 != null) {
      return h3();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) {
    return h3(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) {
    return h3?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) {
    if (h3 != null) {
      return h3(this);
    }
    return orElse();
  }
}

abstract class TypeScaleTypeH3 extends TypeScaleType {
  const factory TypeScaleTypeH3() = _$TypeScaleTypeH3;
  const TypeScaleTypeH3._() : super._();
}

/// @nodoc
abstract class $TypeScaleTypeBodyCopyWith<$Res> {
  factory $TypeScaleTypeBodyCopyWith(
          TypeScaleTypeBody value, $Res Function(TypeScaleTypeBody) then) =
      _$TypeScaleTypeBodyCopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeBodyCopyWithImpl<$Res>
    extends _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeBodyCopyWith<$Res> {
  _$TypeScaleTypeBodyCopyWithImpl(
      TypeScaleTypeBody _value, $Res Function(TypeScaleTypeBody) _then)
      : super(_value, (v) => _then(v as TypeScaleTypeBody));

  @override
  TypeScaleTypeBody get _value => super._value as TypeScaleTypeBody;
}

/// @nodoc

class _$TypeScaleTypeBody extends TypeScaleTypeBody
    with DiagnosticableTreeMixin {
  const _$TypeScaleTypeBody() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TypeScaleType.body()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TypeScaleType.body'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TypeScaleTypeBody);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) {
    return body();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) {
    return body?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) {
    if (body != null) {
      return body();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) {
    return body(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) {
    return body?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) {
    if (body != null) {
      return body(this);
    }
    return orElse();
  }
}

abstract class TypeScaleTypeBody extends TypeScaleType {
  const factory TypeScaleTypeBody() = _$TypeScaleTypeBody;
  const TypeScaleTypeBody._() : super._();
}

/// @nodoc
abstract class $TypeScaleTypeBodyMonoCopyWith<$Res> {
  factory $TypeScaleTypeBodyMonoCopyWith(TypeScaleTypeBodyMono value,
          $Res Function(TypeScaleTypeBodyMono) then) =
      _$TypeScaleTypeBodyMonoCopyWithImpl<$Res>;
}

/// @nodoc
class _$TypeScaleTypeBodyMonoCopyWithImpl<$Res>
    extends _$TypeScaleTypeCopyWithImpl<$Res>
    implements $TypeScaleTypeBodyMonoCopyWith<$Res> {
  _$TypeScaleTypeBodyMonoCopyWithImpl(
      TypeScaleTypeBodyMono _value, $Res Function(TypeScaleTypeBodyMono) _then)
      : super(_value, (v) => _then(v as TypeScaleTypeBodyMono));

  @override
  TypeScaleTypeBodyMono get _value => super._value as TypeScaleTypeBodyMono;
}

/// @nodoc

class _$TypeScaleTypeBodyMono extends TypeScaleTypeBodyMono
    with DiagnosticableTreeMixin {
  const _$TypeScaleTypeBodyMono() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TypeScaleType.bodyMono()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'TypeScaleType.bodyMono'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TypeScaleTypeBodyMono);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() h1,
    required TResult Function() h2,
    required TResult Function() h3,
    required TResult Function() body,
    required TResult Function() bodyMono,
  }) {
    return bodyMono();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
  }) {
    return bodyMono?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? h1,
    TResult Function()? h2,
    TResult Function()? h3,
    TResult Function()? body,
    TResult Function()? bodyMono,
    required TResult orElse(),
  }) {
    if (bodyMono != null) {
      return bodyMono();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TypeScaleTypeH1 value) h1,
    required TResult Function(TypeScaleTypeH2 value) h2,
    required TResult Function(TypeScaleTypeH3 value) h3,
    required TResult Function(TypeScaleTypeBody value) body,
    required TResult Function(TypeScaleTypeBodyMono value) bodyMono,
  }) {
    return bodyMono(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
  }) {
    return bodyMono?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TypeScaleTypeH1 value)? h1,
    TResult Function(TypeScaleTypeH2 value)? h2,
    TResult Function(TypeScaleTypeH3 value)? h3,
    TResult Function(TypeScaleTypeBody value)? body,
    TResult Function(TypeScaleTypeBodyMono value)? bodyMono,
    required TResult orElse(),
  }) {
    if (bodyMono != null) {
      return bodyMono(this);
    }
    return orElse();
  }
}

abstract class TypeScaleTypeBodyMono extends TypeScaleType {
  const factory TypeScaleTypeBodyMono() = _$TypeScaleTypeBodyMono;
  const TypeScaleTypeBodyMono._() : super._();
}
